# design-pattern
java设计模式收集

### 模块分类

- Behavioral-*：表示行为型设计模式
- Structural-*：表示结构型设计模式
- Creational-*：表示创建型设计模式

### 模块说明

- Behavioral-ChainOfResponsibility：责任链模式
- Behavioral-Command：命令模式
- Behavioral-Iterator：迭代器模式
- Behavioral-Mediator：中介者模式
- Behavioral-Memento：备忘录模式
- Behavioral-Observer：观察者模式
- Behavioral-State：状态模式
- Behavioral-Strategy：策略模式
- Behavioral-TemplateMethod：模板方法模式
- Behavioral-Visitor：访问者模式


- Creational-AbstractFactory：抽象工厂模式
- Creational-Builder：构建者模式
- Creational-FactoryMethod：工厂方法模式
- Creational-Prototype：原型模式
- Creational-Singleton：单例模式


- Structural-Adapter：适配器模式
- Structural-Bridge：桥接模式
- Structural-Composite：组合模式
- Structural-Decorator：装饰器模式
- Structural-Facade：门面模式
- Structural-Flyweight：享元模式
- Structural-Proxy：代理模式

### 模式解读

代理模式：该模式的意图是通过一个代理或者占位符来控制对该对象的访问。对于客户端而言，它并不知道它正在和一个代理打交道。

适配器模式：适配器的意图是使用不同接口的类所提供的服务为客户端提供它所期望的接口。适配器模式分为接口适配（类适配）、类与对象适配。当需要适配的方法并非定义在接口时就需要使用类与对象的适配了。继承需要适配的方法所在的类，将请求委派给依赖的具体实现类的对象进行处理。类与对象的适配可以实现双向适配。另一种有争议的适配器模式就是一个抽象类实现了一个接口的所有方法，但是都是空方法，这样做的目的是防止只需要实现接口一个方法的类直接实现接口又不得不实现所有方法的问题。对象适配器模式有3在角色：目标Target，目标是一个接口，该接口是客户想使用的接口；被适配者Adaptee，被适配者是一个已经存在的接口或者抽象类，这个接口或者抽象类需要适配；适配器Adapter，适配器是一个类，该类实现了目标接口并包含有被适配者的引用，即适配器的职责是对被适配者接口或者抽象类与目标接口进行适配。

外观模式：外观模式的意图是为子系统提供一个接口，便于它的使用。它可能全是静态方法。外观类通常是可配置的、便于重用的、提供了高层次的接口。外观模式包含2中角色：子系统Subsystem,子系统是若干个类的集合，这些类的实例协同合作为用户提供所需的功能，子系统的任何类都不包含外观类的实例引用；外观Facade,外观是一个类该类包含了子系统中全部或部分类的实例引用，当用户想和子系统的类的实例打交道时，可以代替地和子系统的外观类的实例打交道。

组合模式：组合模式的意图是为了保证客户端调用单对象与组合对象的一致性。组合对象和单对象共享同一个接口。只有当应用程序的核心模型可以表示为树时，使用组合模式才有意义。组合模式包含3种角色：抽象组件Component，一个接口或抽象类，抽象组件定义了个体对象和组合对象需要实现的关于操作其子节点的方法，比如add(),remove(),getChild()等，也可以定义个体对象和组合对象用于操作其自身的方法，比如isLeaf()；Composite节点，实现Component接口的类的实例，composite节点不仅实现component接口，而且可以含有其他composite节点或leaf节点的引用；Leaf节点，实现Component接口的类的实例，leaf节点不可以含有其他composite节点或者leaf节点的引用，因此叶节点在实现component接口有关操作子节点的方法时，比如add(),remove(),getChild()时可以抛出一个异常，也可以实现为空操作。

桥接模式：将抽象部分和它的实现部分分离，使他们都可以独立的变化。也就是将一个抽象类中的抽象方法的重要实现部分交给另外一个抽象类的子类或实现另外一个接口的类。

单例模式：单例模式的意图是为了确保一个类有且仅有一个实例，并为它提供一个全局访问点。根据单例创建时机的不同分为懒汉模式和恶汉模式。

观察者模式：观察者模式的意图是在多个对象之间定义一对多的依赖关系，当一个对象的状态发生改变时，会通知依赖于它的对象，并且这些对象会根据新状态做出相应的反应。被观察者对象在通知观察者时有2种方式，一种是推模式，一种的拉模式。推模式下会推送变更的数据，拉模式只会通知有变更发生，需要观察者自己获取变更的数据并作出响应。当处理多主题的时候应当使用拉模式。该模式有四种角色：主题Subject，主题是一个接口，该接口规定了具体主题需要实现的方法，比如添加删除观察者以及通知观察者更新数据的方法;观察者Observer,观察者是一个接口，该接口规定了具体观察者用来更新数据的方法；具体主题ConcreteSubject，具体主题是实现主题的一个实现类，该实例包含了可以经常发生变化的数据。具体主题需要使用一个集合存放观察则的引用，以便数据方式变化时通知具体的观察者；具体的观察者ConcreteObserver，是观察者接口的一个实例。具体观察者包含有主题接口变量，以便具体观察者让具体主题将自己的引用添加到具体主题的集合中，使自己成为它的观察者，或者让具体主题将自己从具体主题的集合中删除，使自己不再是它的观察者。

中介者模式：该模式的意图是定义一个对象，封装一组对象的交互，从而降低对象间的耦合度，避免了对象间的显示引用，并且可以独立的改变对象的行为。无论何时，只要对象之间存在复杂的交互行为，就可以将这些交互职责集中到这些对象等之外的一个中介者对象中。当对象和中介者交互时通常要把自己的身份信息和交互的信息发送给中介者，这样中介者才能根据不同的身份进行对应的交互。该模式经常用在GUI程序开发中。中介者模式包含4种角色：中介者Mediator，中介者是一个接口，该接口定义了用于同事Colleague对象之间进行通信的方法；具体中介者ConcreteMediator，具体中介者需要包含所有具体同事ConcreteColleague的引用，并通过实现中介者接口中的方法来满足具体同事之间的通信请求；同事Colleague，一个接口，规定了具体同事需要实现的方法；具体同事ConcreteColleague，具体同事需要包含具体中介者的引用，一个具体同事需要和其他具体同事交互时，只需要将自己的请求通知给它所包含的具体中介者即可。

责任链模式：该模式的目的在于通过给予多个对象处理请求的机会，以解除请求的发送者和处理者之间的耦合。将这些对象练成一条链，请求在这条链中传递，直到有一个对象对其进行处理。这些对象都有选择处理请求和将请求传递给下一个处理对象的权利。这些对象即可使上下级关系也可以是并列与协作的关系。该模式有2在角色：处理者Handler，处理者是一个接口，规定具体处理者处理用户请求的方法已经具体处理者设置后继对象的方法。具体处理者ConcreteHandler,具体处理者在处理请求的过程中如果发现能处理用户的请求，就处理有关的数据，否则就将用户的请求传递给自己的后继对象。

享元模式：该模式的意图是通过共享来有效的支持大量对象细粒度的对象。享元对象不可变且只能由享元工厂创建，具体的享元类可以设置为享元工厂的私有静态内部类。通常将大量细粒度的对象的不可变部分抽离出来封装在享元对象里面，这样在创建大量细粒度的对象时就不必创建这些不变的数据了，直接引用享元对象就可以了。

构建者模式：该模式的意图是将类的构建逻辑转移到类的实例化外部。在创建对象之前，逐步收集创建对象需要的信息，用于构建复杂的对象。通常需要将构建过程封装到director中。对象的创建通常会有一些逻辑，这些逻辑在对象创建完之后就不再有意义，可以将这些逻辑封装到构建者中。构建者模式包含4种角色：产品Product，具体构建者要构建的复杂的对象；抽象构建者Builder，一个接口，该接口除了为创建一个product对象的各个组件定义的若干个方法外，还要定义返回product对象的方法；具体构建者ConcreteBuilder，Builder的实现类；指挥者Director，一个类，该类需包含Builder接口声明的变量。指挥者将请求具体构建者来构造用户所需的Product对象，如果所请求的具体构建者成功的构建出Product对象，指挥者就可以让具体构建者返回所构造的Product对象。

工厂方法模式：该模式的意图是定义一个用于创建对象的接口，并控制返回哪个类的实例。在某些场景下用户不关心或者不需要关心是哪个具体类的实例化，或者用户不知道用哪个构造函数实例化类，或者用户不知道有哪些子类或者实现类可以用，工厂方法解决了这个问题。工厂方法模式不仅要求有一个能够创建新对象的方法，还要让客户端无须了解具体实例化的类。Collection接口的iterator()方法就是工厂方法。工厂方法模式包含4种角色：抽象产品Product，抽象类或者接口；具体产品ConcreteProduct，抽象产品的子类或实现；构造者Creator，一个接口或者抽象类，构造者负责定义一个称为工厂方法的抽象方法，该方法返回具体产品类的实例；具体构造者ConcreteCreator，构造者的子类或实现，重写工厂方法使该方法返回具体产品的实例。

抽象工厂模式：抽象工厂模式又名工具箱，其意图是允许创建一族相关或相互依赖的对象。GUI工具箱是抽象工厂模式的一个典型案例，它为用户提供各种GUI控件，例如客户所在的国家决定不同的界面风格。抽象工厂模式使得客户端代码在需要新对象的时候，无需关心该对象是由哪个类实例化的。就这点而言，抽象工厂就是工厂方法的集合。在某些情况下，工厂方法模式的设计可能会迈向抽象工厂模式的设计。抽象工厂模式包含4种角色：抽象产品Product,一个接口或者抽象类；具体产品ConcreteProduct，抽象产品的子类或实现；抽象工厂AbstractFactory，一个接口或者抽象类，负责定义若干个抽象方法；具体工厂ConcreteFactory，抽象工厂的子类或实现类，重写抽象工厂中的抽象方法，是该方法返回具体产品的实例。

原型模式：原型模式的意图是通过复制一个现有的对象来生成新的对象，而不是通过实例化的方式。在某些情况下，可能不希望反复使用类的构造方法创建许多对象，而是希望用该类创建一个对象后，以该对象为原型得到该对象的若干个复制品。即将一个对象定义为原型对象，要求该原型对象提供一个方法，使调用该方法可以复制一个和自己有完全相同状态的同类型对象，且原型对象和复制出来的对象的状态可以独立地变化而不相互影响。当创建类的新实例代价更大时，原型模式可以提高创建新实例的效率（见案例：com.zboy.example.creational.prototype.example02.Apple）。原型模式包含2种角色：抽象原型Prototype，一个接口，负责定义对象复制自身的方法；具体原型ConcretePrototype，抽象原型的实现类，具体原型实现抽象原型中的抽象方法，以便客户端调用该方法复制自己。

备忘录模式：备忘录模式的意图是为对象状态提供存储和恢复功能。在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态。备忘录是一个用来存储对象状态的小型数据仓库。通常，可以用一个对象、字符串或者文件来创建备忘录。在该模式中，需要保存状态的对象是“原发者”，负责保存原发者状态的对象是“备忘录”，负责管理备忘录的对象是“负责人”。

模板方法模式：模板方法的意图是在一个方法里实现一个算法，并推迟定义算法中的某些步骤，从而让其他类重新定义它们也不会改变整个算法的骨架。钩子方法是一个回调方法，它可以让其他开发者将自己的代码插入到程序的指定位置。通常开发者会为钩子方法提供一个存根实现，一旦其他客户端不需要钩子方法就没必要再重写它。模板方法模式通常会使用钩子方法调用子类的实现。模板方法模式可以作为开发者之间的一种契约。魔板方法模式的意图并不是要求我们在定义子类前写出模板方法，可能会在已有的类层次中发现一些相似的地方，此时可以将相似的地方提取为模板方法。

状态模式：状态模式的意图是将表示对象状态的逻辑分散到代表状态的不同类中。该模式将状态建模为对象，并把状态相关的逻辑封装到独立的类中。环境状态的更新可以由状态类完成也可以有状态类返回再由自己更新。

策略模式：策略模式的意图是将可互换的方法封装在各自独立的类中，并且让每个方法都实现一个公共的操作。策略模式可以让一组策略共存，代码互不干扰。它还将策略选择的逻辑从策略本身中分离了出来。不同的策略可以相互替换。策略模式包含3种角色：策略Strategy，策略是一个接口，该接口定义了若干个算法标识，即若干个抽象方法。具体策略ConcreteStrategy，具体策略是实现策略接口的类，是具体实现；上下文Context，上下文包含有策略声明的变量，上下文提供一个方法，该方法委托策略变量调用具体策略所实现的策略接口中的方法。

命令模式：命令模式的意图是将请求封装在对象内部。直接调用是执行方法的一般方式。然而，有时我们无法控制方法执行的时机与上下文。这种情况下，可以将方法封装在对象的内部。通过在对象内部存储调用方法所需要的信息，就可以让客户端或者服务决定何时调用该方法。可以对请求进行排队或者记录请求日志，以及支持可撤销的操作。菜单是应用命令模式的一个经典案例，菜单项知道何时执行一个请求，但却不知道应该去执行什么请求。如果请求者不希望或无法直接和被请求者打交道，即不希望或无法含有被请求者的引用，就可以使用命令模式。执行者不直接与接收者交互，即调用者不包含接受者的引用。程序需要在不同的时刻指定、排列和执行请求时可以使用该模式。该模式有四种角色，接受者Receiver，该实例负责执行与请求相关的操作；命令接口Command,规定了封装请求的方法，如execute（）,undo（）等；具体命令ConcreteCommand，需实现Command接口；调用者Invoker，invoker包含了一个Command接口变量的类的实例，invoker负责调用具体命令。

装饰器模式：装饰器模式的意图是在运行时组合操作的新变化。即动态地给对象添加一些额外的职责。在某些情况下，你需要对象的行为发生一些细小的变化，并且这些变化可以进行组合。装饰器模式在输入输出流应用中获得了巨大的成功。该模式有四种角色：抽象组件Component，抽象组件是一个抽象类，定义了“被装饰者”需要进行装饰的方法；具体组件ConcreteComponent，是抽象组件的一个子类，具体组件的实例称作“被装饰者”；装饰Decorator，装饰也是抽象组件的一个子类，但装饰还包含一个抽象组件的变量以保存“被装饰者”的引用，装饰可以是抽象类也可以是非抽象类，如果是非抽象类，那么该类的实例称作是“装饰者”；具体装饰ConcreteDecorator,具体装饰是装饰的一个非抽象子类，具体装饰的实例称为“装饰者”。

迭代器模式：迭代器模式的意图是为顺序访问集合元素提供一种方式。该模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。当让用户访问一个集合中的对象，但不想暴露对象在集合中的存储结构，或者希望对遍历不同的集合提供一个统一的接口时，可以使用迭代器模式。该模式需要四种角色：集合Aggregate，一个接口，规定了具体集合需要实现的操作；具体集合ConcreteAggregate，具体集合是实现集合接口的类的实例，具体集合安装一定结构存储对象。具体集合应当有一个方法，该方法返回一个针对该集合的具体迭代器；迭代器Iterator，一个接口，规定了遍历具体集合的方法，比如next()方法；具体迭代器ConcreteIterator，具体迭代器在实现迭代器接口所规定的遍历集合的方法时，比如next()，要保证next()方法的首次调用将按照集合的数据结构找到该集合中的一个对象，而且每当找到集合中的一个对象，立刻根据该集合的存储结构得到待遍历的后继对象的引用，并保证依次调用next()方法可以遍历集合。

访问者模式：访问者模式的意图是在不改变类层次结构的前提下，对该层次结构进行扩展。访问者模式包括5种角色，抽象元素Element、具体元素Concrete Element、对象结构Object Structure、抽象访问者和具体访问者。访问者模式可以在Visitor类中集中定义一些关于集合中对象的操作。

